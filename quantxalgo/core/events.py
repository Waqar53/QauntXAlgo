from __future__ import annotations

"""
Event system for the event-driven backtester.

This module defines all event types used in the trading simulation.
Events are the fundamental unit of communication between components.
"""

from abc import ABC
from dataclasses import dataclass, field
from datetime import datetime
from typing import Any, Optional, Tuple
from uuid import uuid4

from quantxalgo.core.enums import Side, OrderType, TimeInForce, EventType


@dataclass(frozen=True, order=True)
class Event(ABC):
    """Base class for all events in the system.
    
    Events are immutable and ordered by timestamp for priority queue processing.
    """
    
    # Sort by timestamp, then by event type priority
    sort_index: tuple = field(init=False, repr=False)
    
    timestamp: datetime
    event_type: EventType = field(default=EventType.SIGNAL)  # Default, subclasses override
    event_id: str = field(default_factory=lambda: str(uuid4()))
    
    def __post_init__(self) -> None:
        # Create sort key: (timestamp, event_type_priority)
        object.__setattr__(
            self, 
            'sort_index', 
            (self.timestamp, self.event_type.priority)
        )



@dataclass(frozen=True)
class MarketDataEvent(Event):
    """Market data update event (new bar or tick).
    
    Emitted when new market data is available for processing.
    """
    
    symbol: str = ""
    open: float = 0.0
    high: float = 0.0
    low: float = 0.0
    close: float = 0.0
    volume: float = 0.0
    vwap: float | None = None
    
    def __post_init__(self) -> None:
        object.__setattr__(self, 'event_type', EventType.MARKET_DATA)
        super().__post_init__()
    
    @property
    def ohlcv(self) -> tuple[float, float, float, float, float]:
        """Return OHLCV as a tuple."""
        return (self.open, self.high, self.low, self.close, self.volume)
    
    @property
    def mid_price(self) -> float:
        """Return mid price (average of high and low)."""
        return (self.high + self.low) / 2
    
    @property
    def typical_price(self) -> float:
        """Return typical price (HLC average)."""
        return (self.high + self.low + self.close) / 3


@dataclass(frozen=True)
class SignalEvent(Event):
    """Trading signal generated by a strategy.
    
    Represents the intent to trade, not an actual order.
    """
    
    symbol: str = ""
    side: Side = Side.BUY
    strength: float = 1.0  # Signal strength in range [0, 1]
    strategy: str = ""
    target_quantity: float | None = None
    target_price: float | None = None
    reason: str = ""
    metadata: dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self) -> None:
        object.__setattr__(self, 'event_type', EventType.SIGNAL)
        super().__post_init__()
    
    @property
    def is_buy(self) -> bool:
        return self.side == Side.BUY
    
    @property
    def is_sell(self) -> bool:
        return self.side == Side.SELL


@dataclass(frozen=True)
class OrderEvent(Event):
    """Order submission event.
    
    Represents an order to be sent to the execution engine.
    """
    
    order_id: str = field(default_factory=lambda: str(uuid4()))
    symbol: str = ""
    side: Side = Side.BUY
    order_type: OrderType = OrderType.MARKET
    quantity: float = 0.0
    limit_price: float | None = None
    stop_price: float | None = None
    time_in_force: TimeInForce = TimeInForce.DAY
    strategy: str = ""
    signal_id: str | None = None  # Reference to originating signal
    
    def __post_init__(self) -> None:
        object.__setattr__(self, 'event_type', EventType.ORDER)
        super().__post_init__()
    
    @property
    def is_market_order(self) -> bool:
        return self.order_type == OrderType.MARKET
    
    @property
    def is_limit_order(self) -> bool:
        return self.order_type in (OrderType.LIMIT, OrderType.STOP_LIMIT)
    
    @property
    def notional_value(self) -> float | None:
        """Estimated notional value of the order."""
        if self.limit_price:
            return self.quantity * self.limit_price
        return None


@dataclass(frozen=True)
class FillEvent(Event):
    """Order fill/execution event.
    
    Represents a completed execution, either full or partial.
    """
    
    fill_id: str = field(default_factory=lambda: str(uuid4()))
    order_id: str = ""
    symbol: str = ""
    side: Side = Side.BUY
    quantity: float = 0.0
    price: float = 0.0
    commission: float = 0.0
    slippage: float = 0.0
    is_partial: bool = False
    remaining_quantity: float = 0.0
    strategy: str = ""
    
    def __post_init__(self) -> None:
        object.__setattr__(self, 'event_type', EventType.FILL)
        super().__post_init__()
    
    @property
    def notional_value(self) -> float:
        """Total notional value of the fill."""
        return self.quantity * self.price
    
    @property
    def total_cost(self) -> float:
        """Total cost including commission."""
        if self.side == Side.BUY:
            return self.notional_value + self.commission
        else:
            return -self.notional_value + self.commission
    
    @property
    def effective_price(self) -> float:
        """Price including slippage."""
        return self.price


@dataclass(frozen=True)
class PortfolioEvent(Event):
    """Portfolio update event.
    
    Emitted when portfolio state changes significantly.
    """
    
    total_equity: float = 0.0
    cash: float = 0.0
    positions_value: float = 0.0
    unrealized_pnl: float = 0.0
    realized_pnl: float = 0.0
    drawdown: float = 0.0
    
    def __post_init__(self) -> None:
        object.__setattr__(self, 'event_type', EventType.PORTFOLIO)
        super().__post_init__()


@dataclass(frozen=True)
class RiskEvent(Event):
    """Risk management event.
    
    Emitted when risk limits are breached or warnings triggered.
    """
    
    risk_type: str = ""  # DRAWDOWN, EXPOSURE, POSITION_SIZE, etc.
    severity: str = ""   # WARNING, CRITICAL, EMERGENCY
    message: str = ""
    current_value: float = 0.0
    threshold: float = 0.0
    action: str = ""     # REDUCE, HEDGE, LIQUIDATE, NONE
    
    def __post_init__(self) -> None:
        object.__setattr__(self, 'event_type', EventType.RISK)
        super().__post_init__()
    
    @property
    def is_critical(self) -> bool:
        return self.severity in ("CRITICAL", "EMERGENCY")


@dataclass(frozen=True)
class SystemEvent(Event):
    """System-level event.
    
    Used for system notifications, heartbeats, and control messages.
    """
    
    message: str = ""
    level: str = "INFO"  # INFO, WARNING, ERROR
    component: str = ""
    metadata: dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self) -> None:
        object.__setattr__(self, 'event_type', EventType.SYSTEM)
        super().__post_init__()
